%{

#include "parser.tab.hpp"
#include "symbol_table.hpp"
#include <cstdio>
#include <iostream>

extern int yylex();
extern int curr_line;
extern int curr_column;

SymbolTableStack symbol_table_stack;

void yyerror(char *s) {
    fprintf(stderr, "at line %i and column %i: %s\n", curr_line, curr_column, s);
}

void check_type(Type lhs, Type rhs) {
    //TODO
}

void check_type_comp_op(Type lhs, Type rhs) {
    // TODO
}

void check_type_arith_op(Type lhs, Type rhs) {
    // TODO
}

void check_bool(Type i) {
    // TODO
}

void ce

%}

%union {
    struct {
        int value;
        int line, column;
    } int_value;
    struct {
        float value;
        int line, column;
    } float_value;
    struct {
        char *value;
        int line, column;
    } string_value;
    struct {
        char *name;
        int line, column;
    } id;
    struct {
        int line, column;
    } general_values;
} 

%token <id> ID
%token <int_value> INT_LITERAL
%token <float_value> FLOAT_LITERAL
%token <string_value> STRING_LITERAL
%token <general_values> KW_PROGRAM
%token <general_values> KW_PROCEDURE
%token <general_values> KW_BEGIN
%token <general_values> KW_END
%token <general_values> KW_IN
%token <general_values> KW_STRUCT
%token <general_values> KW_VAR
%token <general_values> KW_INT
%token <general_values> KW_FLOAT
%token <general_values> KW_STRING
%token <general_values> KW_BOOL
%token <general_values> KW_REF
%token <general_values> KW_DEREF
%token <general_values> KW_RETURN
%token <general_values> KW_WHILE
%token <general_values> KW_DO
%token <general_values> KW_OD
%token <general_values> KW_IF
%token <general_values> KW_THEN
%token <general_values> KW_ELSE
%token <general_values> KW_FI
%token <general_values> KW_TRUE
%token <general_values> KW_FALSE
%token <general_values> KW_NEW
%token <general_values> KW_NULL
%token <general_values> KW_SEMICOLUMN
%token <general_values> KW_COLUMN
%token <general_values> KW_COMMA
%token <general_values> KW_DOT
%token <general_values> KW_EXIT
%token <general_values> KW_WHEN
%token <general_values> OP_ADD
%token <general_values> OP_SUB
%token <general_values> OP_MULT
%token <general_values> OP_DIV
%token <general_values> OP_EXP
%token <general_values> UMINUS
%token <general_values> OP_ASSIGN
%token <general_values> OP_NOT
%token <general_values> OP_AND
%token <general_values> OP_OR
%token <general_values> OP_SMALLER
%token <general_values> OP_SMALLER_OR_EQ
%token <general_values> OP_GREATER
%token <general_values> OP_GREATER_OR_EQ
%token <general_values> OP_EQUAL
%token <general_values> OP_NOT_EQUAL
%token <general_values> OPEN_PAREN
%token <general_values> CLOSE_PAREN
%token <general_values> OPEN_CURLY
%token <general_values> CLOSE_CURLY
%token SYMBOL_UNKNOKW
%token TYPE_PROCEDURE
%token TYPE_VOID
%token TYPE_STRUCT
%token TYPE_INT
%token TYPE_FLOAT
%token TYPE_BOOL
%token TYPE_STRING
%token TYPE_REFERENCE

// precedence related stuff
%start program

%left OP_OR
%left OP_AND

%nonassoc OP_NOT_EQUAL OP_EQUAL
%nonassoc OP_SMALLER OP_GREATER OP_SMALLER_OR_EQ OP_GREATER_OR_EQ

%left OP_ADD OP_SUB
%left OP_MULT OP_DIV

%right OP_EXP
%right UMINUS OP_NOT
%nonassoc OPEN_PAREN CLOSE_PAREN
%right KW_DOT
%right KW_REF KW_DEREF

%%

program : KW_PROGRAM ID KW_BEGIN opt_decl_list KW_END {}
        ;

opt_decl_list : /* empty */ {}
              | decl_list {}
              ;

decl_list : decl {}
          | decl_list KW_SEMICOLUMN decl {}
          ;

decl : var_decl { $$ = $1; }      // Propagate TypeNode from var_decl
     | proc_decl { $$ = $1; }     // Propagate TypeNode from proc_decl
     | rec_decl { $$ = $1; }      // Propagate TypeNode from rec_decl
     ;

var_decl : KW_VAR ID KW_COLUMN type {
    symbol_table.insert({$2.name, Type($4)});
    $$ = $4;
}
| KW_VAR ID KW_COLUMN type OP_ASSIGN exp {
    if ($4 != $6) 
        typeerror();
    
    symbol_table.insert({$2.name, Type($4)});
    $$ = $4;
}
| KW_VAR ID OP_ASSIGN exp {
    symbol_table.insert({$2.name, Type($4)});
    $$ = $4;
}
;

opt_proc_return_type : /*empty*/ {
    $$ = TYPE_VOID;
}
| KW_COLUMN type {
    $$ = $2;
}
;

proc_decl : KW_PROCEDURE {symbol_table_stack.open_scope();} ID OPEN_PAREN opt_paramfield_decl_list_comma CLOSE_PAREN opt_proc_return_type KW_BEGIN 
                proc_body KW_END {
                    std::vector<Type> param_list = symbol_table_stack.top().get_types();
                    symbol_table_stack.close_scope();
                    symbol_table_stack.insert({$3.name, param_list, Type($7)});
                    $$ = $7;
                }
          ; 

proc_body : opt_stmt_list { $$ = $1; }
          | opt_decl_list KW_IN opt_stmt_list{ $$ = $3; }
          ;

rec_decl : KW_STRUCT {symbol_table_stack.open_scope();} ID OPEN_CURLY opt_paramfield_decl_list_semicolumn CLOSE_CURLY {
    SymbolTable struct_table = symbol_table_stack.top();
    symbol_table_stack.close_scope();
    symbol_table_stack.insert({$3.name, Type($3.name, &struct_table)});
}
;

paramfield_decl : ID KW_COLUMN type {}
                ;

opt_paramfield_decl_list_comma : /* empty */
                               | paramfield_decl_list_comma {}
                               ;

opt_paramfield_decl_list_semicolumn : /* empty */
                                    | paramfield_decl_list_semicolumn {}
                                    ;

paramfield_decl_list_comma : paramfield_decl {}
                           | paramfield_decl KW_COMMA paramfield_decl_list_comma {}
                           ;

paramfield_decl_list_semicolumn : paramfield_decl {}
                                | paramfield_decl KW_SEMICOLUMN paramfield_decl_list_semicolumn {}
                                ;

opt_stmt_list : /* empty */ {}
              | stmt_list {}
              ;

stmt_list : stmt {}
          | stmt_list KW_SEMICOLUMN stmt {}
          ;

exp : exp OP_AND exp { 
        check_type($1, $3); 
        check_bool($1);
        $$ = $1;
    }
    | exp OP_OR exp {
        check_type($1, $3); 
        check_bool($1);
        $$ = $1;
    }
    | OP_NOT exp %prec OP_NOT {
        check_bool($2);
        $$ = $2;
    }

    | exp OP_SMALLER exp  {
        check_type_comp_op($1, $3); 
        $$ = $1;
    }
    | exp OP_SMALLER_OR_EQ exp  {
        check_type_comp_op($1, $3); 
        $$ = $1;
    }
    | exp OP_GREATER exp  {
        check_type_comp_op($1, $3); 
        $$ = $1;
    }
    | exp OP_GREATER_OR_EQ exp  {
        check_type_comp_op($1, $3); 
        $$ = $1;
    }
    | exp OP_EQUAL exp  {
        check_type_comp_op($1, $3); 
        $$ = $1;
    }
    | exp OP_NOT_EQUAL exp  {
        check_type_comp_op($1, $3); 
        $$ = $1;
    }

    | exp OP_ADD exp {
        check_type_arith_op($1, $3); 
        $$ = $1;
    }
    | exp OP_SUB exp {
        check_type_arith_op($1, $3); 
        $$ = $1;
    }
    | exp OP_MULT exp {
        check_type_arith_op($1, $3); 
        $$ = $1;
    }
    | exp OP_DIV exp {
        check_type_arith_op($1, $3); 
        $$ = $1;
    }
    | exp OP_EXP exp {
        check_type_arith_op($1, $3); 
        $$ = $1;
    }
    | OP_SUB exp %prec UMINUS {
        check_type_arith_op($1, $3); 
        $$ = $1;
    }

    | literal { $$ = $1; }
    | call_stmt {$$ = $1; }
    | KW_NEW ID {}
    | var {}
    | ref_var {}
    | deref_var {}
    | OPEN_PAREN exp CLOSE_PAREN {$$ = $2; }
    ;

ref_var : KW_REF OPEN_PAREN var CLOSE_PAREN {}

deref_var : KW_DEREF OPEN_PAREN var CLOSE_PAREN {}
          | KW_DEREF OPEN_PAREN deref_var CLOSE_PAREN {}
          ;

var : ID {}
    | exp KW_DOT ID {}
    ;

literal : FLOAT_LITERAL {
    $$ = TYPE_FLOAT;
}
| INT_LITERAL {
    $$ = TYPE_INT;
}
| STRING_LITERAL {
    $$ = TYPE_STRING;
}
| bool_literal { 
    $$ = $1; 
} 
| KW_NULL {
    $$ = TYPE_REFERENCE;
}
;

bool_literal : KW_TRUE {
    $$ = TYPE_BOOL;
}
| KW_FALSE {
    $$ = TYPE_BOOL;
}
;

stmt : assign_stmt {}
     | if_stmt {}
     | while_stmt {} 
     | return_stmt {}
     | call_stmt {}
     | do_while_stmt {}
     ;

assign_stmt : var OP_ASSIGN exp {}
            | deref_var OP_ASSIGN exp {}
            ;

opt_else_stmt : /* empty */ {}
              | KW_ELSE opt_stmt_list {}
              ;

if_stmt : KW_IF exp KW_THEN opt_stmt_list opt_else_stmt KW_FI {}
        ;

while_stmt : KW_WHILE exp KW_DO opt_stmt_list KW_OD {}
           ;

return_stmt : KW_RETURN exp {}
            ;

opt_exp_list : /* empty */ {}
             | exp_list {}
             ;

exp_list : exp {}
         | exp_list KW_COMMA exp {}

call_stmt : ID OPEN_PAREN opt_exp_list CLOSE_PAREN {}
          ;

do_while_stmt : KW_DO do_while_opt_stmt_list {symbol_table_stack.open_scope();} KW_OD {
    symbol_table_stack.close_scope();
}
;

do_while_opt_stmt_list : /* empty */ {}
                       | if_stmt {}
                       | assign_stmt {}
                       | return_stmt { $$ = $1; }
                       | call_stmt {}
                       | do_while_stmt {}
                       | KW_EXIT KW_WHEN exp {}
                       ;

type : KW_FLOAT { $$ = TYPE_FLOAT; }
     | KW_INT { $$ = TYPE_INT; }
     | KW_STRING { $$ = TYPE_STRING; }
     | KW_BOOL { $$ = TYPE_BOOL; }
     | ID { $$ = TYPE_STRUCT; }
     | KW_REF OPEN_PAREN type CLOSE_PAREN { $$ = TYPE_REF; }
     ;

%%
