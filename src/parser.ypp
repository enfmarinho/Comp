%{
#include "parser.tab.hpp"
#include "symbol_table.hpp"
#include "symbol_table_stack.hpp"
#include "type.hpp"

#include <cstdio>
#include <memory>

extern int yylex();
extern int curr_line;
extern int curr_column;

TypePtr expected_proc_return_type = std::make_shared<Type>(NoType);
SymbolTableStack symbol_table_stack;

void yyerror(const char *s) {
    fprintf(stderr, "at line %i and column %i: %s\n", curr_line, curr_column, s);
    YYABORT;
}

std::string type_name(TypePtr type) {
    if (type->base_type == Void) {
        return "void";
    } else if (type->base_type == Int) {
        return "int";
    } else if (type->base_type == Float) {
        return "float";
    } else if (type->base_type == String) {
        return "string";
    } else if (type->base_type == Bool) {
        return "bool";
    } else if (type->base_type == Struct) {
        std::string name = "struct ";
        name += type->struct_type_name;
        return name;
    } else if (type->base_type == Ref) {
        std::string name = "ref to ";
        name += type_name(type->referenced_type);
        return name;
    } else {
        // Should not reach this, since does not make sence to call
        // this functions when type is Procedure, Error or NoType
        assert("false");
    }
}

void assert_type(TypePtr lhs, TypePtr rhs) {
    if (lhs->base_type != rhs->base_type)
        yyerror("Type mismatch");
    if (lhs->base_type == Ref)
        assert_type(lhs->referenced_type, rhs->referenced_type);
    if (lhs->base_type == Struct && lhs->struct_type_name != rhs->struct_type_name)
        yyerror("Type mismatch");
}

bool types_match(TypePtr lhs, TypePtr rhs) {
    if (lhs->base_type != rhs->base_type)
        return false;
    if (lhs->base_type == Ref)
        return types_match(lhs->referenced_type, rhs->referenced_type);
    if (lhs->base_type == Struct && lhs->struct_type_name != rhs->struct_type_name)
        return false;

    return true;
}

void assert_type_comp_op(TypePtr lhs, TypePtr rhs) {
    assert_type(lhs, rhs);
    if (lhs->base_type != Int and lhs->base_type != Float) 
        yyerror("Comparison operations must be performed for int or for float");
}

void assert_type_arith_op(TypePtr lhs, TypePtr rhs) {
    assert_type(lhs, rhs);
    if (lhs->base_type != Int and lhs->base_type != Float) 
        yyerror("Arithmetic operations must be performed only on int types or float types");
}

void assert_bool(TypePtr i) {
    if (i->base_type != Bool)
        yyerror("Boolean operations must be performed only on bool types");
}

void assert_condition(TypePtr type) {
    if(type->base_type != Bool) 
        yyerror("condition must be bool");
}

%}

%code requires {
    #include <memory>
    #include <vector>
    #include "type.hpp"

    using TypePtr = std::shared_ptr<Type>;
    using TypeList = std::vector<TypePtr>;
    using TypeListPtr = std::shared_ptr<TypeList>;
}

%union {
    struct {
        int value;
        int line, column;
    } int_value;
    struct {
        float value;
        int line, column;
    } float_value;
    struct {
        char *value;
        int line, column;
    } string_value;
    struct {
        char *name;
        int line, column;
    } id;
    struct {
        int line, column;
    } general_values;
    TypePtr type;
    TypeListPtr type_list;
} 

%destructor { $$.~shared_ptr(); } <type>
%destructor { $$.~shared_ptr(); } <type_list>

%token <id> ID
%token <int_value> INT_LITERAL
%token <float_value> FLOAT_LITERAL
%token <string_value> STRING_LITERAL
%token <general_values> KW_PROGRAM
%token <general_values> KW_PROCEDURE
%token <general_values> KW_BEGIN
%token <general_values> KW_END
%token <general_values> KW_IN
%token <general_values> KW_STRUCT
%token <general_values> KW_VAR
%token <general_values> KW_INT
%token <general_values> KW_FLOAT
%token <general_values> KW_STRING
%token <general_values> KW_BOOL
%token <general_values> KW_REF
%token <general_values> KW_DEREF
%token <general_values> KW_RETURN
%token <general_values> KW_WHILE
%token <general_values> KW_DO
%token <general_values> KW_OD
%token <general_values> KW_IF
%token <general_values> KW_THEN
%token <general_values> KW_ELSE
%token <general_values> KW_FI
%token <general_values> KW_TRUE
%token <general_values> KW_FALSE
%token <general_values> KW_NEW
%token <general_values> KW_NULL
%token <general_values> KW_SEMICOLUMN
%token <general_values> KW_COLUMN
%token <general_values> KW_COMMA
%token <general_values> KW_DOT
%token <general_values> KW_EXIT
%token <general_values> KW_WHEN
%token <general_values> OP_ADD
%token <general_values> OP_SUB
%token <general_values> OP_MULT
%token <general_values> OP_DIV
%token <general_values> OP_EXP
%token <general_values> UMINUS
%token <general_values> OP_ASSIGN
%token <general_values> OP_NOT
%token <general_values> OP_AND
%token <general_values> OP_OR
%token <general_values> OP_SMALLER
%token <general_values> OP_SMALLER_OR_EQ
%token <general_values> OP_GREATER
%token <general_values> OP_GREATER_OR_EQ
%token <general_values> OP_EQUAL
%token <general_values> OP_NOT_EQUAL
%token <general_values> OPEN_PAREN
%token <general_values> CLOSE_PAREN
%token <general_values> OPEN_CURLY
%token <general_values> CLOSE_CURLY

%type <type> type
%type <type> exp
%type <type> literal
%type <type> bool_literal
%type <type> var
%type <type> deref_var
%type <type> ref_var
%type <type> call_stmt
%type <type> return_stmt
%type <type> opt_proc_return_type
%type <type> paramfield_decl

%type <type_list> opt_paramfield_decl_list_comma
%type <type_list> paramfield_decl_list_comma
%type <type_list> opt_arguments_list
%type <type_list> argument_list

// precedence related stuff
%start program

%left OP_OR
%left OP_AND

%nonassoc OP_NOT_EQUAL OP_EQUAL
%nonassoc OP_SMALLER OP_GREATER OP_SMALLER_OR_EQ OP_GREATER_OR_EQ

%left OP_ADD OP_SUB
%left OP_MULT OP_DIV

%right OP_EXP
%right UMINUS OP_NOT
%nonassoc OPEN_PAREN CLOSE_PAREN
%right KW_DOT
%right KW_REF KW_DEREF

%%

program : KW_PROGRAM ID KW_BEGIN opt_decl_list KW_END {}
        ;

opt_decl_list : /* empty */ {}
              | decl_list {}
              ;

decl_list : decl {}
          | decl_list KW_SEMICOLUMN decl {}
          ;

decl : var_decl {}
     | proc_decl {}
     | rec_decl {}
     ;

var_decl : KW_VAR ID KW_COLUMN type {
    symbol_table_stack.insert({$2.name, *$4});
}
| KW_VAR ID KW_COLUMN type OP_ASSIGN exp {
    assert_type($4, $6);
    symbol_table_stack.insert({$2.name, *$4});
}
| KW_VAR ID OP_ASSIGN exp {
    symbol_table_stack.insert({$2.name, *$4});
}
;

opt_proc_return_type : /*empty*/ {
    $$ = std::make_shared<Type>(Void);
}
| KW_COLUMN type {
    $$ = $2;
}
;

proc_decl : KW_PROCEDURE {symbol_table_stack.open_scope();} ID OPEN_PAREN opt_paramfield_decl_list_comma CLOSE_PAREN
            opt_proc_return_type {expected_proc_return_type = $7;} KW_BEGIN proc_body KW_END {
              symbol_table_stack.close_scope();
              symbol_table_stack.insert({$3.name, Type(Procedure, *$5, $7)});
              expected_proc_return_type = std::make_shared<Type>(NoType);
          }
          ; 

proc_body : opt_stmt_list {}
          | opt_decl_list KW_IN opt_stmt_list {}
          ;

rec_decl : KW_STRUCT {symbol_table_stack.open_scope();} ID OPEN_CURLY opt_paramfield_decl_list_semicolumn CLOSE_CURLY {
    SymbolTable struct_table = symbol_table_stack.top();
    symbol_table_stack.close_scope();
    symbol_table_stack.insert({$3.name, Type(Struct, $3.name, &struct_table)});
}
;

paramfield_decl : ID KW_COLUMN type {
                    symbol_table_stack.insert({$1.name, *$3});
                    $$ = std::make_shared<Type>($3);
                }
                ;

opt_paramfield_decl_list_comma : /* empty */ {$$ = std::make_shared<TypeList>();}
                               | paramfield_decl_list_comma { $$ = $1; }
                               ;

opt_paramfield_decl_list_semicolumn : /* empty */
                                    | paramfield_decl_list_semicolumn {}
                                    ;

paramfield_decl_list_comma : paramfield_decl {
                               $$ = std::make_shared<TypeList>();
                               $$.get()->push_back($1);
                           }
                           // TODO check this
                           | paramfield_decl_list_comma KW_COMMA paramfield_decl {
                               $$ = $1;
                               $$.get()->push_back($3);
                           }
                           ;

paramfield_decl_list_semicolumn : paramfield_decl {}
                                | paramfield_decl KW_SEMICOLUMN paramfield_decl_list_semicolumn {}
                                ;

opt_stmt_list : /* empty */ {}
              | stmt_list {}
              ;

stmt_list : stmt {}
          | stmt_list KW_SEMICOLUMN stmt {}
          ;

stmt : assign_stmt {}
     | if_stmt {}
     | while_stmt {} 
     | return_stmt { 
         if (!types_match($1, expected_proc_return_type)) {
             std::string error_message = "Mismatched types: returns ";
             error_message += type_name($1);
             error_message += " expected ";
             error_message += type_name(expected_proc_return_type);
             yyerror(error_message.c_str());
         }
     }
     | call_stmt {}
     | do_while_stmt {}
     ;

exp : exp OP_AND exp { 
        assert_type($1, $3); 
        assert_bool($1);
        $$ = $1;
    }
    | exp OP_OR exp {
        assert_type($1, $3); 
        assert_bool($1);
        $$ = $1;
    }
    | OP_NOT exp %prec OP_NOT {
        assert_bool($2);
        $$ = $2;
    }

    | exp OP_SMALLER exp  {
        assert_type_comp_op($1, $3); 
        $$ = std::make_shared<Type>(Bool);
    }
    | exp OP_SMALLER_OR_EQ exp  {
        assert_type_comp_op($1, $3); 
        $$ = std::make_shared<Type>(Bool);
    }
    | exp OP_GREATER exp  {
        assert_type_comp_op($1, $3); 
        $$ = std::make_shared<Type>(Bool);
    }
    | exp OP_GREATER_OR_EQ exp  {
        assert_type_comp_op($1, $3); 
        $$ = std::make_shared<Type>(Bool);
    }
    | exp OP_EQUAL exp  {
        assert_type_comp_op($1, $3); 
        $$ = std::make_shared<Type>(Bool);
    }
    | exp OP_NOT_EQUAL exp  {
        assert_type_comp_op($1, $3); 
        $$ = std::make_shared<Type>(Bool);
    }

    | exp OP_ADD exp {
        assert_type_arith_op($1, $3); 
        $$ = $1;
    }
    | exp OP_SUB exp {
        assert_type_arith_op($1, $3); 
        $$ = $1;
    }
    | exp OP_MULT exp {
        assert_type_arith_op($1, $3); 
        $$ = $1;
    }
    | exp OP_DIV exp {
        assert_type_arith_op($1, $3); 
        $$ = $1;
    }
    | exp OP_EXP exp {
        assert_type_arith_op($1, $3); 
        $$ = $1;
    }
    | OP_SUB exp %prec UMINUS {
        assert_type_arith_op($2, $2); 
        $$ = $2;
    }
    | literal { $$ = $1; }
    | call_stmt { $$ = $1; }
    | KW_NEW ID { 
        Type id_type;
        symbol_table_stack.consult($2.name, id_type);
        if (id_type.base_type != Struct) 
            yyerror("Use new keyword only to instantiate structs");

        $$ = std::make_shared<Type>(Struct, $2.name); 
    }
    | var { $$ = $1; }
    | ref_var { $$ = $1; }
    | deref_var { $$ = $1; }
    | OPEN_PAREN exp CLOSE_PAREN { $$ = $2; }
    ;

ref_var : KW_REF OPEN_PAREN var CLOSE_PAREN { $$ = std::make_shared<Type>(Ref, $3); }

deref_var : KW_DEREF OPEN_PAREN var CLOSE_PAREN { 
              if ($3->base_type != Ref) 
                  yyerror("Trying to deref a non ref type");
              $$ = $3->referenced_type; 
          }
          | KW_DEREF OPEN_PAREN deref_var CLOSE_PAREN { 
              if ($3->base_type != Ref) 
                  yyerror("Trying to deref a non ref type");
              $$ = $3->referenced_type; 
          }
          ;

var : ID { 
    Type id_type;
    if (!symbol_table_stack.consult($1.name, id_type)) {
        std::string error_message = "var \'";
        error_message += $1.name;
        error_message += "\' not declared";
        yyerror(error_message.c_str());
    }
    
    $$ = std::make_shared<Type>(id_type); 
}
| exp KW_DOT ID {
    std::string struct_name = $1->struct_type_name;
    if ($1->base_type != Struct) 
        yyerror("Use the dot reference operation only for structs");

    Type struct_type, member_type;
    if (!symbol_table_stack.consult(struct_name, struct_type)) {
        // Should never fall here
        std::string error_message = "struct \'";
        error_message += struct_name;
        error_message += "\' not declared";
        yyerror(error_message.c_str());
    }

    if (!struct_type.symbol_table->consult($3.name, member_type)) {
        std::string error_message = "No member \'";
        error_message += $3.name;
        error_message += "\' in ";
        error_message += struct_name;
        yyerror(error_message.c_str());
    }
    
    $$ = std::make_shared<Type>(member_type); 
}
;

literal : FLOAT_LITERAL {
    $$ = std::make_shared<Type>(Float);
}
| INT_LITERAL {
    $$ = std::make_shared<Type>(Int);
}
| STRING_LITERAL {
    $$ = std::make_shared<Type>(String);
}
| bool_literal { 
    $$ = $1; 
} 
| KW_NULL {
    $$ = std::make_shared<Type>(Ref, nullptr);
}
;

bool_literal : KW_TRUE {
    $$ = std::make_shared<Type>(Bool);
}
| KW_FALSE {
    $$ = std::make_shared<Type>(Bool);
}
;

assign_stmt : var OP_ASSIGN exp {}
            | deref_var OP_ASSIGN exp {}
            ;

opt_else_stmt : /* empty */ {}
              | KW_ELSE opt_stmt_list {}
              ;

if_stmt : KW_IF exp {assert_condition($2);} KW_THEN opt_stmt_list opt_else_stmt KW_FI {}
        ;

while_stmt : KW_WHILE exp {assert_condition($2);} KW_DO opt_stmt_list KW_OD {}
           ;

return_stmt : KW_RETURN exp {
    $$ = $2;
}
;

opt_arguments_list : /* empty */ { $$ = std::make_shared<TypeList>(); }
                   | argument_list { $$ = $1; }
                   ;

argument_list : exp { 
                  $$ = std::make_shared<TypeList>();
                  $$.get()->push_back($1);
              }
              // TODO check this
              | argument_list KW_COMMA exp {
                  $$ = $1;
                  $$.get()->push_back($3);
              }

call_stmt : ID OPEN_PAREN opt_arguments_list CLOSE_PAREN {
    Type proc_type;
    if (!symbol_table_stack.consult($1.name, proc_type)) {
        std::string error_message = "procedure \'";
        error_message += $1.name;
        error_message += "\' not declared";
        yyerror(error_message.c_str());
    }

    // Check if number of arguments passed match with expected number of arguments
    TypeList param_types = *$3;
    TypeList expected_param_types = proc_type.param_types;
    if (param_types.size() != expected_param_types.size()) {
        std::string error_message = "Procedure \'";
        error_message += $1.name;
        error_message += "\' expected ";
        error_message += std::to_string(expected_param_types.size());
        error_message += " arguments, but received ";
        error_message += std::to_string(param_types.size());
        yyerror(error_message.c_str());
    }
    
    // Check if arguments types match with expected types
    for (int idx = 0; idx < param_types.size(); ++idx) {
        if (!types_match(param_types[idx], expected_param_types[idx])) {
            std::string error_message = "Argument ";
            error_message += std::to_string(idx);
            error_message += " does not match expected type for procedure \'";
            error_message += $1.name;
            error_message += "\'";
            yyerror(error_message.c_str());
        }
    }
     
    $$ = std::make_shared<Type>(proc_type.return_type);
}
;

do_while_stmt : KW_DO do_while_opt_stmt_list KW_OD {}
              ;

do_while_opt_stmt_list : /* empty */ {}
                       | if_stmt {}
                       | assign_stmt {}
                       | return_stmt {}
                       | call_stmt {}
                       | do_while_stmt {}
                       | while_stmt {}
                       | KW_EXIT KW_WHEN exp {assert_condition($3);}
                       ;

type : KW_FLOAT { $$ = std::make_shared<Type>(Float); }
     | KW_INT { $$ = std::make_shared<Type>(Int); }
     | KW_STRING { $$ = std::make_shared<Type>(String); }
     | KW_BOOL { $$ = std::make_shared<Type>(Bool); }
     | ID { $$ = std::make_shared<Type>(Struct, $1.name); }
     | KW_REF OPEN_PAREN type CLOSE_PAREN { $$ = std::make_shared<Type>(Ref, std::make_shared<Type>($3)); }
     ;

%%
