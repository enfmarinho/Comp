%{
#include "parser.tab.hpp"
#include "symbol_table.hpp"
#include "symbol_table_stack.hpp"
#include <cstdlib>
#include <vector>
#include <ifstream>
#include "type.hpp"

#include <cstdio>

extern int yylex();
extern int past_token_line;
extern int past_token_column;
extern std::ifstream file_out;

struct Data {
  std::string var_name;
  std::string label; 
  std::string label_true, label_false; // For if stmt
  StmtListType stmt_list;
  Type type;

  Data(std::string var_name, std::string label, std::string label_true, std::string label_false
        StmtListType stmt_list, Type type) : var_name(var_name), label(label),
                                            label_true(label_true), label_false(label_false)
                                            stmt_list(stmt_list), type(type) {}
};

struct Literal {
    Type type;
    std::string lexema;

    Literal(Literal cp) = default;
    Literal(Type type, char *l) : type(type) {
        lexema = std::string(l);
    }
};

TypePtr expected_proc_return_type = new Type(NoType);
SymbolTableStack symbol_table_stack;

StmtListType decl_buf;
StmtListType label_buf;

int lc = 0; // label counter
int vc = 0; // var counter

StmtListType conc_list(StmtListType lhs, StmtListType rhs) {
    StmtListType stmt_list;
    for (std::string decl : lhs) {
        stmt_list.push_back(decl);
    }
    for (std::string decl : rhs) {
        stmt_list.push_back(decl);
    }
    return stmt_list;
}

std::string new_var(Type type, std::string var_name="") {
    if (var_name == "")
        std::string var_name = "t" + to_string(vc++);

    decl_buf.push_back(type_name(type) + " " + var_name + ";\n");
    return var_name;
}

std::string new_label(StmtListType buf, std::string label_name="") {
    if (label_name == "")
        std::string label_name = "l" + std::to_string(lc++);

    label_buf.push_back(label_name + ": \n");
    for (std::string s : buf) {
        label_buf.push_back(s);
    }
    return label_name;
}

void flush_file() {
    for (std::string decl : decl_buf) {
        file_out << decl;
    }

    file_out << "int main() {\n";
    for (std::strint label : label_buf) {
        file_out << label;
    }
    file_out << "}";
}

void yyerror(const char *s) {
    fprintf(stderr, "at line %i and column %i: %s\n", past_token_line, past_token_column, s);
}

std::string type_name(TypePtr type) {
    if (type->base_type == Void) {
        return "void";
    } else if (type->base_type == Int) {
        return "int";
    } else if (type->base_type == Float) {
        return "float";
    } else if (type->base_type == String) {
        return "string";
    } else if (type->base_type == Bool) {
        return "bool";
    } else if (type->base_type == Struct) {
        std::string name = "struct ";
        name += type->struct_type_name;
        return name;
    } else if (type->base_type == Ref) {
        name += type_name(type->referenced_type);
        name += "*";
        return name;
    } else if (type->base_type == Struct) {
        return type->struct_type_name;
    } else {
        // Should not reach this, since does not make sence to call
        // this functions when type is Error or NoType
        assert("false");
    }
    return "";
}

void assert_type(TypePtr lhs, TypePtr rhs, std::string error_message="") {
    if (error_message == "") {
        error_message = "Mismatched types: "; 
        error_message += "expected ";
        error_message += type_name(lhs);
        error_message += " but found ";
        error_message += type_name(rhs);
    }

    if (lhs->base_type != rhs->base_type)
        yyerror(error_message.c_str());
    if (lhs->base_type == Ref)
        assert_type(lhs->referenced_type, rhs->referenced_type);
    if (lhs->base_type == Struct && lhs->struct_type_name != rhs->struct_type_name)
        yyerror(error_message.c_str());
}

bool types_match(TypePtr lhs, TypePtr rhs) {
    if (lhs->base_type != rhs->base_type)
        return false;
    if (lhs->base_type == Ref)
        return types_match(lhs->referenced_type, rhs->referenced_type);
    if (lhs->base_type == Struct && lhs->struct_type_name != rhs->struct_type_name)
        return false;

    return true;
}

void assert_type_comp_op(TypePtr lhs, TypePtr rhs) {
    if (lhs->base_type != Int and lhs->base_type != Float) 
        yyerror("Comparison operations must be performed for int or for float");
    std::string error_message = "Trying to perform an comparison operation with different type variables: ";
    error_message += type_name(lhs);
    error_message += " and ";
    error_message += type_name(rhs);
    assert_type(lhs, rhs, error_message);
}

void assert_type_arith_op(TypePtr lhs, TypePtr rhs) {
    if (lhs->base_type != Int and lhs->base_type != Float) 
        yyerror("Arithmetic operations must be performed only on int types or float types");
    std::string error_message = "Trying to perform an arithmetic operation with different type variables: ";
    error_message += type_name(lhs);
    error_message += " and ";
    error_message += type_name(rhs);
    assert_type(lhs, rhs, error_message);
}

void assert_bool(TypePtr i) {
    if (i->base_type != Bool)
        yyerror("Boolean operations must be performed only on bool types");
}

void assert_condition(TypePtr type) {
    if(type->base_type != Bool) 
        yyerror("condition must be bool");
}

%}

%code requires {
    #include <vector>
    #include "type.hpp"

    using StmtListType = std::vector<std::string>;
    using TypePtr = Type*;
    using TypeList = std::vector<TypePtr>;
    using TypeListPtr = TypeList*;
}

%union {
    struct {
        char *value;
        int line, column;
    } literal_value;
    struct {
        char *name;
        int line, column;
    } id;
    struct {
        int line, column;
    } general_values;
    TypePtr type;
    TypeListPtr type_list;
    Data* data;
    Literal* literal;
} 

// %destructor { delete $$.name; } <id>
// %destructor { delete $$.value; } <literal_value>
// %destructor { delete $$; } <type>
// %destructor { delete $$; } <type_list>

%token <id> ID
%token <literal_value> INT_LITERAL
%token <literal_value> FLOAT_LITERAL
%token <literal_value> STRING_LITERAL
%token <general_values> KW_PROGRAM
%token <general_values> KW_PROCEDURE
%token <general_values> KW_BEGIN
%token <general_values> KW_END
%token <general_values> KW_IN
%token <general_values> KW_STRUCT
%token <general_values> KW_VAR
%token <general_values> KW_INT
%token <general_values> KW_FLOAT
%token <general_values> KW_STRING
%token <general_values> KW_BOOL
%token <general_values> KW_REF
%token <general_values> KW_DEREF
%token <general_values> KW_RETURN
%token <general_values> KW_WHILE
%token <general_values> KW_DO
%token <general_values> KW_OD
%token <general_values> KW_IF
%token <general_values> KW_THEN
%token <general_values> KW_ELSE
%token <general_values> KW_FI
%token <general_values> KW_TRUE
%token <general_values> KW_FALSE
%token <general_values> KW_NEW
%token <general_values> KW_NULL
%token <general_values> KW_SEMICOLUMN
%token <general_values> KW_COLUMN
%token <general_values> KW_COMMA
%token <general_values> KW_DOT
%token <general_values> KW_EXIT
%token <general_values> KW_WHEN
%token <general_values> OP_ADD
%token <general_values> OP_SUB
%token <general_values> OP_MULT
%token <general_values> OP_DIV
%token <general_values> OP_EXP
%token <general_values> UMINUS
%token <general_values> OP_ASSIGN
%token <general_values> OP_NOT
%token <general_values> OP_AND
%token <general_values> OP_OR
%token <general_values> OP_SMALLER
%token <general_values> OP_SMALLER_OR_EQ
%token <general_values> OP_GREATER
%token <general_values> OP_GREATER_OR_EQ
%token <general_values> OP_EQUAL
%token <general_values> OP_NOT_EQUAL
%token <general_values> OPEN_PAREN
%token <general_values> CLOSE_PAREN
%token <general_values> OPEN_CURLY
%token <general_values> CLOSE_CURLY

%type <type> type
%type <data> exp
%type <literal> literal
%type <literal> bool_literal
%type <type> var
%type <type> deref_var
%type <type> ref_var
%type <data> call_stmt
%type <type> return_stmt
%type <data> if_stmt
%type <type> opt_proc_return_type
%type <type> paramfield_decl

%type <type_list> opt_paramfield_decl_list_comma
%type <type_list> paramfield_decl_list_comma
%type <type_list> opt_arguments_list
%type <type_list> argument_list

// precedence related stuff
%start program

%left OP_OR
%left OP_AND

%nonassoc OP_NOT_EQUAL OP_EQUAL
%nonassoc OP_SMALLER OP_GREATER OP_SMALLER_OR_EQ OP_GREATER_OR_EQ

%left OP_ADD OP_SUB
%left OP_MULT OP_DIV

%right OP_EXP
%right UMINUS OP_NOT
%nonassoc OPEN_PAREN CLOSE_PAREN
%right KW_DOT
%right KW_REF KW_DEREF

%%

program : KW_PROGRAM ID KW_BEGIN opt_decl_list KW_END {}
        ;

opt_decl_list : /* empty */ {}
              | decl_list {}
              ;

decl_list : decl {}
          | decl_list KW_SEMICOLUMN decl {}
          ;

decl : var_decl {}
     | proc_decl {}
     | rec_decl {}
     ;

var_decl : KW_VAR ID KW_COLUMN type {
    symbol_table_stack.insert({$2.name, *$4});
}
| KW_VAR ID KW_COLUMN type OP_ASSIGN exp {
    assert_type($4, $6);
    symbol_table_stack.insert({$2.name, *$4});
}
| KW_VAR ID OP_ASSIGN exp {
    symbol_table_stack.insert({$2.name, *$4});
}
;

opt_proc_return_type : /*empty*/ {
    $$ = new Type(Void);
}
| KW_COLUMN type {
    $$ = new Type(*$2);
}
;

proc_decl : KW_PROCEDURE {symbol_table_stack.open_scope();} ID OPEN_PAREN opt_paramfield_decl_list_comma CLOSE_PAREN
            opt_proc_return_type {*expected_proc_return_type = *$7;} KW_BEGIN proc_body KW_END {
              symbol_table_stack.close_scope();
              symbol_table_stack.insert({$3.name, Type(Procedure, *$5, $7)});
              *expected_proc_return_type = Type(NoType);
          }
          ; 

proc_body : opt_stmt_list {}
          | opt_decl_list KW_IN opt_stmt_list {}
          ;

rec_decl : KW_STRUCT {symbol_table_stack.open_scope();} ID OPEN_CURLY opt_paramfield_decl_list_semicolumn CLOSE_CURLY {
    SymbolTable struct_table = symbol_table_stack.top();
    symbol_table_stack.close_scope();
    symbol_table_stack.insert({$3.name, Type(Struct, $3.name, &struct_table)});
}
;

paramfield_decl : ID KW_COLUMN type {
                    symbol_table_stack.insert({$1.name, *$3});
                    $$ = new Type(*$3);
                }
                ;

opt_paramfield_decl_list_comma : /* empty */ {$$ = new TypeList();}
                               | paramfield_decl_list_comma { 
                                   $$ = new TypeList();
                                   *$$ = *$1; 
                               }
                               ;

opt_paramfield_decl_list_semicolumn : /* empty */
                                    | paramfield_decl_list_semicolumn {}
                                    ;

paramfield_decl_list_comma : paramfield_decl {
                               $$ = new TypeList();
                               $$->push_back($1);
                           }
                           | paramfield_decl_list_comma KW_COMMA paramfield_decl {
                               $$ = new TypeList();
                               *$$ = *$1;
                               $$->push_back($3);
                           }
                           ;

paramfield_decl_list_semicolumn : paramfield_decl {}
                                | paramfield_decl KW_SEMICOLUMN paramfield_decl_list_semicolumn {}
                                ;

opt_stmt_list : /* empty */ {}
              | stmt_list {}
              ;

stmt_list : stmt {}
          | stmt_list KW_SEMICOLUMN stmt {}
          ;

stmt : assign_stmt {}
     | if_stmt {}
     | while_stmt {} 
     | return_stmt { 
         if (!types_match($1, expected_proc_return_type)) {
             std::string error_message = "Mismatched types: returns ";
             error_message += type_name($1);
             error_message += " expected ";
             error_message += type_name(expected_proc_return_type);
             yyerror(error_message.c_str());
         }
     }
     | call_stmt {}
     | do_while {}
     ;

exp : exp OP_AND exp { 
        assert_bool($1);
        assert_bool($3);

        std::string var_name = new_var();
        StmtListType stmt_list = conc_list($1->stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "&&" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", "", "", stmt_list, Type(*$1));
    }
    | exp OP_OR exp {
        assert_bool($1);
        assert_bool($3);

        std::string var_name = new_var();
        StmtListType stmt_list = conc_list($1->stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "||" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", "", "", stmt_list, Type(*$1));
    }
    | OP_NOT exp %prec OP_NOT {
        assert_bool($2);

        std::string var_name = new_var();
        StmtListType stmt_list = $2->stmt_list;
        stmt_list.push_back(var_name + " = !" + $2->var_name + ";\n");
        $$ = new Data(var_name, "", "", "", stmt_list, Type(*$1));
    }

    | exp OP_SMALLER exp  {
        assert_type_comp_op($1, $3); 

        std::string var_name = new_var();
        StmtListType stmt_list = conc_list($1->stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "<" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", "", "", stmt_list, Type(Bool));
    }
    | exp OP_SMALLER_OR_EQ exp  {
        assert_type_comp_op($1, $3); 

        std::string var_name = new_var();
        StmtListType stmt_list = conc_list($1->stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "<=" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", "", "", stmt_list, Type(Bool));
    }
    | exp OP_GREATER exp  {
        assert_type_comp_op($1, $3); 

        std::string var_name = new_var();
        StmtListType stmt_list = conc_list($1->stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + ">" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", "", "", stmt_list, Type(Bool));
    }
    | exp OP_GREATER_OR_EQ exp  {
        assert_type_comp_op($1, $3); 

        std::string var_name = new_var();
        StmtListType stmt_list = conc_list($1->stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + ">=" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", "", "", stmt_list, Type(Bool));
    }
    | exp OP_EQUAL exp  {
        assert_type_comp_op($1, $3); 

        std::string var_name = new_var();
        StmtListType stmt_list = conc_list($1->stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "==" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", "", "", stmt_list, Type(Bool));
    }
    | exp OP_NOT_EQUAL exp  {
        assert_type_comp_op($1, $3); 

        std::string var_name = new_var();
        StmtListType stmt_list = conc_list($1->stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "!=" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", "", "", stmt_list, Type(Bool));
    }

    | exp OP_ADD exp {
        assert_type_arith_op($1, $3); 

        std::string var_name = new_var();
        StmtListType stmt_list = conc_list($1->stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "+" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", "", "", stmt_list, Type(*$1));
    }
    | exp OP_SUB exp {
        assert_type_arith_op($1, $3); 

        std::string var_name = new_var();
        StmtListType stmt_list = conc_list($1->stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "-" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", "", "", stmt_list, Type(*$1));
    }
    | exp OP_MULT exp {
        assert_type_arith_op($1, $3); 

        std::string var_name = new_var();
        StmtListType stmt_list = conc_list($1->stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "*" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", "", "", stmt_list, Type(*$1));
    }
    | exp OP_DIV exp {
        assert_type_arith_op($1, $3); 

        std::string var_name = new_var();
        StmtListType stmt_list = conc_list($1->stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "/" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", "", "", stmt_list, Type(*$1));
    }
    | exp OP_EXP exp {
        assert_type_arith_op($1, $3); 

        std::string var_name = new_var();
        StmtListType stmt_list = conc_list($1->stmt_list, $3->stmt_list);
        // TODO fix this later, OP_EXP is just a OP_MULT at the moment
        stmt_list.push_back(var_name + " = " + $1->var_name + "*" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", "", "", stmt_list, Type(*$1));
    }
    | OP_SUB exp %prec UMINUS {
        assert_type_arith_op($2, $2); 

        std::string var_name = new_var();
        StmtListType stmt_list = $2->stmt_list;
        stmt_list.push_back(var_name + " = -" + $2->var_name + ";\n");
        $$ = new Data(var_name, "", "", "", stmt_list, Type(*$2));
    }
    | literal { 
        $$ = new Data($1->lexema, "", "", "", {}, $1->type);
    }
    | call_stmt { 
        $$ = new Data(*$1);
    }
    | KW_NEW ID { 
        Type id_type;
        symbol_table_stack.consult($2.name, id_type);
        if (id_type.base_type != Struct) 
            yyerror("Use new keyword only to instantiate structs");

        Type type(Struct, $2.name)
        std::string var_name = new_var(type);
        $$ = new Data(var_name, "", "", "", {}, type); 
    }
    | var { 
    }
    | ref_var { 
    }
    | deref_var { 
    }
    | OPEN_PAREN exp CLOSE_PAREN { 
        $$ = new Data(*$2);
    }
    ;

ref_var : KW_REF OPEN_PAREN var CLOSE_PAREN { $$ = new Type(Ref, $3); }

deref_var : KW_DEREF OPEN_PAREN var CLOSE_PAREN { 
              if ($3->base_type != Ref) 
                  yyerror("Trying to deref a non ref type");
              $$ = new Type(*($3->referenced_type)); 
          }
          | KW_DEREF OPEN_PAREN deref_var CLOSE_PAREN { 
              if ($3->base_type != Ref) 
                  yyerror("Trying to deref a non ref type");
              $$ = new Type(*($3->referenced_type)); 
          }
          ;

var : ID { 
    Type id_type;
    if (!symbol_table_stack.consult($1.name, id_type)) {
        std::string error_message = "var \'";
        error_message += $1.name;
        error_message += "\' not declared";
        yyerror(error_message.c_str());
    }
    
    $$ = new Type(id_type); 
}
| exp KW_DOT ID {
    std::string struct_name = $1->struct_type_name;
    if ($1->base_type != Struct) 
        yyerror("Use the dot reference operation only for structs");

    Type struct_type, member_type;
    if (!symbol_table_stack.consult(struct_name, struct_type)) {
        // Should never fall here
        std::string error_message = "struct \'";
        error_message += struct_name;
        error_message += "\' not declared";
        yyerror(error_message.c_str());
    }

    if (!struct_type.symbol_table->consult($3.name, member_type)) {
        std::string error_message = "No member \'";
        error_message += $3.name;
        error_message += "\' in ";
        error_message += struct_name;
        yyerror(error_message.c_str());
    }
    
    $$ = new Type(member_type); 
}
;

literal : FLOAT_LITERAL {
    $$ = new Literal(Type(Float), $1.literal_value.float);
}
| INT_LITERAL {
    $$ = new Literal(Type(Int), $1.literal_value.value);
}
| STRING_LITERAL {
    $$ = new Literal(Type(String), $1.literal_value.value);
}
| bool_literal { 
    $$ = new Literal(*$1); 
} 
| KW_NULL {
    $$ = new Literal(Type(Ref, nullptr), "null");
}
;

bool_literal : KW_TRUE {
    $$ = new Literal(Type(Bool), "true");
}
| KW_FALSE {
    $$ = new Literal(Type(Bool), "false");
}
;

assign_stmt : var OP_ASSIGN exp {
                assert_type($1, $3);
            }
            | deref_var OP_ASSIGN exp {
                assert_type($1, $3);
            }
            ;

opt_else_stmt : /* empty */ {}
              | KW_ELSE opt_stmt_list {}
              ;

if_stmt : KW_IF exp {assert_condition($2);} KW_THEN opt_stmt_list opt_else_stmt KW_FI {}
        ;

while_stmt : KW_WHILE exp {assert_condition($2);} KW_DO opt_stmt_list KW_OD {}
           ;

return_stmt : KW_RETURN exp {
    $$ = new Type(*$2);
}
;

opt_arguments_list : /* empty */ { $$ = new TypeList(); }
                   | argument_list { 
                       $$ = new TypeList();
                       *$$ = *$1; 
                   }
                   ;

argument_list : exp { 
                  $$ = new TypeList();
                  $$->push_back($1);
              }
              | argument_list KW_COMMA exp {
                  $$ = new TypeList();
                  *$$ = *$1;
                  $$->push_back($3);
              }

call_stmt : ID OPEN_PAREN opt_arguments_list CLOSE_PAREN {
    Type proc_type;
    if (!symbol_table_stack.consult($1.name, proc_type)) {
        std::string error_message = "procedure \'";
        error_message += $1.name;
        error_message += "\' not declared";
        yyerror(error_message.c_str());
    }

    // Check if number of arguments passed match with expected number of arguments
    TypeList param_types = *$3;
    TypeList expected_param_types = proc_type.param_types;
    if (param_types.size() != expected_param_types.size()) {
        std::string error_message = "Procedure \'";
        error_message += $1.name;
        error_message += "\' expected ";
        error_message += std::to_string(expected_param_types.size());
        error_message += " arguments, but received ";
        error_message += std::to_string(param_types.size());
        yyerror(error_message.c_str());
    }
    
    // Check if arguments types match with expected types
    for (int idx = 0; idx < param_types.size(); ++idx) {
        if (!types_match(param_types[idx], expected_param_types[idx])) {
            std::string error_message = "Argument ";
            error_message += std::to_string(idx);
            error_message += " does not match expected type for procedure \'";
            error_message += $1.name;
            error_message += "\'";
            yyerror(error_message.c_str());
        }
    }
     
    $$ = new Type(*proc_type.return_type);
}
;

do_while : KW_DO opt_do_while_stmt_list KW_OD {}
              ;

opt_do_while_stmt_list : /* empty */ {}
                       | do_while_stmt_list

do_while_stmt_list : do_while_stmt {}
                   | do_while_stmt_list KW_SEMICOLUMN do_while_stmt {}

do_while_stmt : if_stmt {}
              | assign_stmt {}
              | return_stmt {}
              | call_stmt {}
              | while_stmt {}
              | KW_EXIT KW_WHEN exp { assert_condition($3); }
              ;

type : KW_FLOAT { $$ = new Type(Float); }
     | KW_INT { $$ = new Type(Int); }
     | KW_STRING { $$ = new Type(String); }
     | KW_BOOL { $$ = new Type(Bool); }
     | ID { $$ = new Type(Struct, $1.name); }
     | KW_REF OPEN_PAREN type CLOSE_PAREN { $$ = new Type(Ref, $3); }
     ;

%%
