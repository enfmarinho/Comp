// TODO error case 1: having a constructor for decl_list deleting $$, may very well free memory twice

%{
#include "parser.tab.hpp"
#include "symbol_table.hpp"
#include "symbol_table_stack.hpp"
#include "type.hpp"

#include <cstdlib>
#include <vector>
#include <stack>
#include <fstream>
#include <cstdio>

extern int yylex();
extern int past_token_line;
extern int past_token_column;
extern std::ofstream file_out;

struct Data {
    std::string var_name;
    std::string label; 
    StmtListType stmt_list;
    Type type;

    Data(std::string var_name, std::string label, 
            StmtListType stmt_list, Type type) : var_name(var_name), label(label), 
                                                 stmt_list(stmt_list), type(type) {}
};

struct Literal {
    Type type;
    std::string lexema;

    Literal(const Literal& cp) = default;
    Literal(Type type, char *l) : type(type) {
        lexema = std::string(l);
    }
};

TypePtr expected_proc_return_type = new Type(NoType);
SymbolTableStack symbol_table_stack;

StmtListType decl_buf;
std::stack<std::string> do_while_end_stack;

int lc = 0; // label counter
int vc = 0; // var counter
int rlc = 0; // return label counter

void conc_list_in_place(StmtListType &lhs, StmtListType rhs) {
    for (std::string decl : rhs) {
        lhs.push_back(decl);
    }
}

void yyerror(const char *s) {
    fprintf(stderr, "at line %i and column %i: %s\n", past_token_line, past_token_column, s);
}

std::string type_name(TypePtr type) {
    if (type->base_type == Void) {
        return "void";
    } else if (type->base_type == Int) {
        return "int";
    } else if (type->base_type == Float) {
        return "float";
    } else if (type->base_type == String) {
        return "char*";
    } else if (type->base_type == Bool) {
        return "bool";
    } else if (type->base_type == Struct) {
        std::string name = "struct ";
        name += type->struct_type_name;
        return name;
    } else if (type->base_type == Ref) {
        std::string name;
        name += type_name(type->referenced_type);
        name += "*";
        return name;
    } else if (type->base_type == Struct) {
        return type->struct_type_name;
    } else {
        // Should not reach this, since does not make sence to call
        // this functions when type is Error or NoType
        assert("false");
    }
    return "";
}

void assert_type(TypePtr lhs, TypePtr rhs, std::string error_message="") {
    if (error_message == "") {
        error_message = "Mismatched types: "; 
        error_message += "expected ";
        error_message += type_name(lhs);
        error_message += " but found ";
        error_message += type_name(rhs);
    }

    if (lhs->base_type != rhs->base_type)
        yyerror(error_message.c_str());
    if (lhs->base_type == Ref)
        assert_type(lhs->referenced_type, rhs->referenced_type);
    if (lhs->base_type == Struct && lhs->struct_type_name != rhs->struct_type_name)
        yyerror(error_message.c_str());
}

bool types_match(Type lhs, Type rhs) {
    if (lhs.base_type != rhs.base_type)
        return false;
    if (lhs.base_type == Ref)
        return types_match(*lhs.referenced_type, *rhs.referenced_type);
    if (lhs.base_type == Struct && lhs.struct_type_name != rhs.struct_type_name)
        return false;

    return true;
}

void assert_type_comp_op(TypePtr lhs, TypePtr rhs) {
    if (lhs->base_type != Int and lhs->base_type != Float) 
        yyerror("Comparison operations must be performed for int or for float");
    std::string error_message = "Trying to perform an comparison operation with different type variables: ";
    error_message += type_name(lhs);
    error_message += " and ";
    error_message += type_name(rhs);
    assert_type(lhs, rhs, error_message);
}

void assert_type_arith_op(TypePtr lhs, TypePtr rhs) {
    if (lhs->base_type != Int and lhs->base_type != Float) 
        yyerror("Arithmetic operations must be performed only on int types or float types");
    std::string error_message = "Trying to perform an arithmetic operation with different type variables: ";
    error_message += type_name(lhs);
    error_message += " and ";
    error_message += type_name(rhs);
    assert_type(lhs, rhs, error_message);
}

void assert_bool(TypePtr i) {
    if (i->base_type != Bool)
        yyerror("Boolean operations must be performed only on bool types");
}

void assert_condition(TypePtr type) {
    if(type->base_type != Bool) 
        yyerror("condition must be bool");
}

std::string new_var(Type type, std::string var_name="") {
    if (var_name == "") {
        var_name = "t" + std::to_string(vc++);
    } else {
        // TODO must append std::to_string(vc++) to the end of var_name, but this has implications
    }
    decl_buf.push_back(type_name(&type) + " " + var_name + ";\n");
    return var_name;
}

std::string new_label(std::string label="", bool procedure=false) {
    if (label == "") 
        label = "l"; 
    if (!procedure)
        label += std::to_string(lc++);
    return label;
}

int new_return_label(StmtListType stmt_list) {
    stmt_list.push_back("return_keys[return_keys_size++] = " + std::to_string(rlc + 1) + ";\n");
    return rlc++;
}

std::string return_func() {
    std::string func = "return_label:\n";
    func += "if (return_keys_size == 0) return 0;\n";
    func += "return_keys_size--;\n";
    std::string var_name = new_var(Type(Int));
    for (int i = 0; i < rlc; ++i) {
        std::string is = std::to_string(i);
        func += var_name;
        func += " = return_keys[return_keys_size] == ";
        func += is;
        func += ";\nif (";
        func += var_name;
        func += ") goto return_label";
        func += is;
        func += ";\n";
    }
    return func;
}

void push_return_key(StmtListType stmt_list, int key) {
    stmt_list.push_back("return_keys[return_keys_size] = " + std::to_string(key) + ";\n");
}

void flush_file(StmtListType instruction_list) {
    decl_buf.push_back("int return_keys[1024];\n");
    decl_buf.push_back("int return_keys_size = 0;\n");

    for (std::string decl : decl_buf) {
        file_out << decl;
    }

    file_out << "int main() {\n  goto main;\n";
    for (std::string instruction : instruction_list) {
        file_out << instruction;
    }
    file_out << "}";
}

%}

%code requires {
    #include <vector>
    #include "type.hpp"

    using StmtListType = std::vector<std::string>;
    using TypePtr = Type*;
    using TypeList = std::vector<TypePtr>;
    using TypeListPtr = TypeList*;

    using DataList = std::vector<Data*>;

    class Data;
    class Literal;
}

%union {
    struct {
        char *value;
        int line, column;
    } literal_value;
    struct {
        char *name;
        int line, column;
    } id;
    TypePtr type;
    TypeListPtr type_list;
    Data* data;
    DataList* data_list;

    Literal* literal;
    StmtListType *stmt_list;
}

// %destructor { delete $$.name; } <id>
// %destructor { delete $$.value; } <literal_value>
// %destructor { delete $$; } <type>
// %destructor { delete $$; } <type_list>

%token <id> ID
%token <literal_value> INT_LITERAL
%token <literal_value> FLOAT_LITERAL
%token <literal_value> STRING_LITERAL
%token KW_PROGRAM
%token KW_PROCEDURE
%token KW_BEGIN
%token KW_END
%token KW_IN
%token KW_STRUCT
%token KW_VAR
%token KW_INT
%token KW_FLOAT
%token KW_STRING
%token KW_BOOL
%token KW_REF
%token KW_DEREF
%token KW_RETURN
%token KW_WHILE
%token KW_DO
%token KW_OD
%token KW_IF
%token KW_THEN
%token KW_ELSE
%token KW_FI
%token KW_TRUE
%token KW_FALSE
%token KW_NEW
%token KW_NULL
%token KW_SEMICOLUMN
%token KW_COLUMN
%token KW_COMMA
%token KW_DOT
%token KW_EXIT
%token KW_WHEN
%token OP_ADD
%token OP_SUB
%token OP_MULT
%token OP_DIV
%token OP_EXP
%token UMINUS
%token OP_ASSIGN
%token OP_NOT
%token OP_AND
%token OP_OR
%token OP_SMALLER
%token OP_SMALLER_OR_EQ
%token OP_GREATER
%token OP_GREATER_OR_EQ
%token OP_EQUAL
%token OP_NOT_EQUAL
%token OPEN_PAREN
%token CLOSE_PAREN
%token OPEN_CURLY
%token CLOSE_CURLY

%type <literal> literal
%type <literal> bool_literal

%type <data> call_stmt
%type <data> exp
%type <data> var
%type <data> deref_var
%type <data> ref_var
%type <data> decl
%type <data> var_decl
%type <data> rec_decl
%type <data> proc_decl
%type <stmt_list> assign_stmt
%type <data> opt_else_stmt

%type <stmt_list> if_stmt
%type <stmt_list> stmt
%type <stmt_list> opt_stmt_list
%type <stmt_list> stmt_list
%type <stmt_list> while_stmt
%type <stmt_list> do_while
%type <stmt_list> opt_do_while_stmt_list
%type <stmt_list> do_while_stmt_list
%type <stmt_list> do_while_stmt
%type <data> return_stmt
%type <stmt_list> proc_body

%type <type> type
%type <type> opt_proc_return_type

%type <data> paramfield_decl
%type <data_list> opt_paramfield_decl_list_comma
%type <data_list> paramfield_decl_list_comma

%type <data_list> opt_paramfield_decl_list_semicolumn
%type <data_list> paramfield_decl_list_semicolumn

%type <data_list> opt_arguments_list
%type <data_list> argument_list
%type <stmt_list> opt_decl_list
%type <stmt_list> decl_list

// precedence related stuff
%start program

%left OP_OR
%left OP_AND

%nonassoc OP_NOT_EQUAL OP_EQUAL
%nonassoc OP_SMALLER OP_GREATER OP_SMALLER_OR_EQ OP_GREATER_OR_EQ

%left OP_ADD OP_SUB
%left OP_MULT OP_DIV

%right OP_EXP
%right UMINUS OP_NOT
%nonassoc OPEN_PAREN CLOSE_PAREN
%right KW_DOT
%right KW_REF KW_DEREF

%%

program : KW_PROGRAM ID KW_BEGIN opt_decl_list KW_END {
            Type type;
            if (!symbol_table_stack.consult("main", type)) {
                yyerror("Missing entry point: a procedure named main has to be declared");
            }
            $4->push_back(return_func());
            flush_file(*$4);
        }
        ;

opt_decl_list : /* empty */ { $$ = new StmtListType(); }
              | decl_list { 
                  $$ = new StmtListType();
                  conc_list_in_place(*$$, *$1);
              }
              ;

decl_list : decl {
              $$ = new StmtListType();
              conc_list_in_place(*$$, $1->stmt_list);
          }
          | decl_list KW_SEMICOLUMN decl {
              // TODO see error case 1
              $$ = $1;
              conc_list_in_place(*$$, $3->stmt_list);
          }
          ;

decl : var_decl { 
         $$ = new Data(*$1);
     }
     | proc_decl { 
         $$ = new Data(*$1);
     }
     | rec_decl { 
         $$ = new Data(*$1);
     }
     ;

var_decl : KW_VAR ID KW_COLUMN type {
    symbol_table_stack.insert({$2.name, *$4});
    new_var(*$4, $2.name);
    $$ = new Data("", "", {}, Type(NoType));
}
| KW_VAR ID KW_COLUMN type OP_ASSIGN exp {
    assert_type($4, &$6->type);
    symbol_table_stack.insert({$2.name, *$4});
    new_var(*$4, $2.name);
    StmtListType stmt_list;
    conc_list_in_place(stmt_list, $6->stmt_list);
    stmt_list.push_back(std::string($2.name) + " = " + $6->var_name + ";\n");
    $$ = new Data("", "", stmt_list, Type(NoType));
}
| KW_VAR ID OP_ASSIGN exp {
    symbol_table_stack.insert({$2.name, $4->type});
    new_var($4->type, $2.name);
    StmtListType stmt_list;
    conc_list_in_place(stmt_list, $4->stmt_list);
    stmt_list.push_back(std::string($2.name) + " = " + $4->var_name + ";\n");
    $$ = new Data("", "", stmt_list, Type(NoType));
}
;

opt_proc_return_type : /*empty*/ {
    $$ = new Type(Void);
}
| KW_COLUMN type {
    $$ = new Type(*$2);
}
;

proc_decl : KW_PROCEDURE {symbol_table_stack.open_scope();} ID OPEN_PAREN opt_paramfield_decl_list_comma CLOSE_PAREN
            opt_proc_return_type {*expected_proc_return_type = *$7;} KW_BEGIN proc_body KW_END {
              symbol_table_stack.close_scope();
              symbol_table_stack.insert({$3.name, Type(Procedure, *$5, $7)});

              // Declare param variables 
              for (Data* data : *$5) {
                  new_var(data->type, data->var_name);
              }
                
              std::string label = new_label(std::string($3.name), true);
              StmtListType stmt_list;
              stmt_list.push_back(label + ":\n");
              conc_list_in_place(stmt_list, *$10);
              stmt_list.push_back("goto return_label;\n");
              $$ = new Data("", "", stmt_list, Type(*expected_proc_return_type));
              expected_proc_return_type = new Type(NoType);
          }
          ; 

proc_body : opt_stmt_list { $$ = new StmtListType(*$1); }
          | opt_decl_list KW_IN opt_stmt_list {
              $$ = new StmtListType(); 
              conc_list_in_place(*$$, *$1);
              conc_list_in_place(*$$, *$3);
          }
          ;

rec_decl : KW_STRUCT {symbol_table_stack.open_scope();} ID OPEN_CURLY opt_paramfield_decl_list_semicolumn CLOSE_CURLY {
    SymbolTable struct_table = symbol_table_stack.top();
    symbol_table_stack.close_scope();
    symbol_table_stack.insert({$3.name, Type(Struct, $3.name, &struct_table)});

    StmtListType stmt_list;
    stmt_list.push_back(std::string("struct ") + $3.name + "{\n");
    for (Data* data : *$5) {
        stmt_list.push_back(type_name(&data->type) + " " + data->var_name + ";\n");
    }
    stmt_list.push_back("};\n");
    
    conc_list_in_place(decl_buf, stmt_list);
    $$ = new Data("", "", {}, Type(NoType));
}
;

paramfield_decl : ID KW_COLUMN type {
                    symbol_table_stack.insert({$1.name, *$3});
                    $$ = new Data($1.name, "", {}, *$3);
                }
                ;

opt_paramfield_decl_list_comma : /* empty */ { $$ = new DataList(); }
                               | paramfield_decl_list_comma { 
                                   $$ = new DataList();
                                   *$$ = *$1; // TODO probably needs to be explicity defined
                               }
                               ;

opt_paramfield_decl_list_semicolumn : /* empty */ { $$ = new DataList(); }
                                    | paramfield_decl_list_semicolumn {
                                        $$ = new DataList();
                                        *$$ = *$1;
                                    }
                                    ;

paramfield_decl_list_comma : paramfield_decl {
                               $$ = new DataList();
                               $$->push_back($1);
                           }
                           | paramfield_decl_list_comma KW_COMMA paramfield_decl {
                               $$ = $1;
                               $$->push_back($3);
                           }
                           ;

paramfield_decl_list_semicolumn : paramfield_decl {
                                    $$ = new DataList();
                                    $$->push_back($1);
                                }
                                | paramfield_decl_list_semicolumn KW_SEMICOLUMN paramfield_decl {
                                    $$ = $1;
                                    $$->push_back($3);
                                }
                                ;

opt_stmt_list : /* empty */ {
                  $$ = new StmtListType();
              }
              | stmt_list {
                  $$ = new StmtListType();
                  conc_list_in_place(*$$, *$1);
              }
              ;

stmt_list : stmt {
              $$ = new StmtListType();
              conc_list_in_place(*$$, *$1);
          }
          | stmt_list KW_SEMICOLUMN stmt {
              // TODO see error case 1
              $$ = $1;
              conc_list_in_place(*$$, *$3);
          }
          ;

stmt : assign_stmt { 
         $$ = new StmtListType();
         conc_list_in_place(*$$, *$1);
     }
     | if_stmt {
         $$ = new StmtListType();
         conc_list_in_place(*$$, *$1);
     }
     | while_stmt {
         $$ = new StmtListType();
         conc_list_in_place(*$$, *$1);
     }
     | return_stmt { 
         if (types_match(*expected_proc_return_type, Type(NoType))) {
             yyerror("Return stmt must be declared only within a procedure scope");
         }
         if (!types_match($1->type, *expected_proc_return_type)) {
             std::string error_message = "Mismatched types: returns ";
             error_message += type_name(&$1->type);
             error_message += " expected ";
             error_message += type_name(expected_proc_return_type);
             yyerror(error_message.c_str());
         }
         $$ = new StmtListType();
         conc_list_in_place(*$$, $1->stmt_list);
     }
     | call_stmt {
         $$ = new StmtListType();
         conc_list_in_place(*$$, $1->stmt_list);
     }
     | do_while {
         $$ = new StmtListType();
         conc_list_in_place(*$$, *$1);
     }
     ;

exp : exp OP_AND exp { 
        assert_bool(&$1->type);
        assert_bool(&$3->type);

        std::string var_name = new_var($1->type);
        StmtListType stmt_list;
        conc_list_in_place(stmt_list, $1->stmt_list);
        conc_list_in_place(stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "&&" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", stmt_list, Type($1->type));
    }
    | exp OP_OR exp {
        assert_bool(&$1->type);
        assert_bool(&$3->type);

        std::string var_name = new_var($3->type);
        StmtListType stmt_list;
        conc_list_in_place(stmt_list, $1->stmt_list);
        conc_list_in_place(stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "||" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", stmt_list, Type($1->type));
    }
    | OP_NOT exp %prec OP_NOT {
        assert_bool(&$2->type);

        std::string var_name = new_var($2->type);
        StmtListType stmt_list = $2->stmt_list;
        stmt_list.push_back(var_name + " = !" + $2->var_name + ";\n");
        $$ = new Data(var_name, "", $2->stmt_list, Type($2->type));
    }

    | exp OP_SMALLER exp  {
        assert_type_comp_op(&$1->type, &$3->type); 

        std::string var_name = new_var($1->type);
        StmtListType stmt_list;
        conc_list_in_place(stmt_list, $1->stmt_list);
        conc_list_in_place(stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "<" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", stmt_list, Type(Bool));
    }
    | exp OP_SMALLER_OR_EQ exp  {
        assert_type_comp_op(&$1->type, &$3->type); 

        std::string var_name = new_var($1->type);
        StmtListType stmt_list;
        conc_list_in_place(stmt_list, $1->stmt_list);
        conc_list_in_place(stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "<=" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", stmt_list, Type(Bool));
    }
    | exp OP_GREATER exp  {
        assert_type_comp_op(&$1->type, &$3->type); 

        std::string var_name = new_var($1->type);
        StmtListType stmt_list;
        conc_list_in_place(stmt_list, $1->stmt_list);
        conc_list_in_place(stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + ">" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", stmt_list, Type(Bool));
    }
    | exp OP_GREATER_OR_EQ exp  {
        assert_type_comp_op(&$1->type, &$3->type); 

        std::string var_name = new_var($1->type);
        StmtListType stmt_list;
        conc_list_in_place(stmt_list, $1->stmt_list);
        conc_list_in_place(stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + ">=" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", stmt_list, Type(Bool));
    }
    | exp OP_EQUAL exp  {
        assert_type_comp_op(&$1->type, &$3->type); 

        std::string var_name = new_var($1->type);
        StmtListType stmt_list;
        conc_list_in_place(stmt_list, $1->stmt_list);
        conc_list_in_place(stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "==" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", stmt_list, Type(Bool));
    }
    | exp OP_NOT_EQUAL exp  {
        assert_type_comp_op(&$1->type, &$3->type); 

        std::string var_name = new_var($1->type);
        StmtListType stmt_list;
        conc_list_in_place(stmt_list, $1->stmt_list);
        conc_list_in_place(stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "!=" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", stmt_list, Type(Bool));
    }

    | exp OP_ADD exp {
        assert_type_arith_op(&$1->type, &$3->type); 

        std::string var_name = new_var($1->type);
        StmtListType stmt_list;
        conc_list_in_place(stmt_list, $1->stmt_list);
        conc_list_in_place(stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "+" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", stmt_list, Type($1->type));
    }
    | exp OP_SUB exp {
        assert_type_arith_op(&$1->type, &$3->type); 

        std::string var_name = new_var($1->type);
        StmtListType stmt_list;
        conc_list_in_place(stmt_list, $1->stmt_list);
        conc_list_in_place(stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "-" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", stmt_list, Type($1->type));
    }
    | exp OP_MULT exp {
        assert_type_arith_op(&$1->type, &$3->type); 

        std::string var_name = new_var($1->type);
        StmtListType stmt_list;
        conc_list_in_place(stmt_list, $1->stmt_list);
        conc_list_in_place(stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "*" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", stmt_list, Type($1->type));
    }
    | exp OP_DIV exp {
        assert_type_arith_op(&$1->type, &$3->type); 

        std::string var_name = new_var($1->type);
        StmtListType stmt_list;
        conc_list_in_place(stmt_list, $1->stmt_list);
        conc_list_in_place(stmt_list, $3->stmt_list);
        stmt_list.push_back(var_name + " = " + $1->var_name + "/" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", stmt_list, Type($1->type));
    }
    | exp OP_EXP exp {
        assert_type_arith_op(&$1->type, &$3->type); 

        std::string var_name = new_var($1->type);
        StmtListType stmt_list;
        conc_list_in_place(stmt_list, $1->stmt_list);
        conc_list_in_place(stmt_list, $3->stmt_list);
        // TODO fix this later, OP_EXP is just a OP_MULT at the moment
        stmt_list.push_back(var_name + " = " + $1->var_name + "*" + $3->var_name + ";\n");
        $$ = new Data(var_name, "", stmt_list, Type($1->type));
    }
    | OP_SUB exp %prec UMINUS {
        assert_type_arith_op(&$2->type, &$2->type); 

        std::string var_name = new_var($2->type);
        $$ = new Data(var_name, "", $2->stmt_list, Type($2->type));
        $$->stmt_list.push_back(var_name + " = -" + $2->var_name + ";\n");
    }
    | literal { 
        $$ = new Data($1->lexema, "", {}, $1->type);
    }
    | call_stmt { 
        $$ = new Data(*$1);
    }
    | KW_NEW ID { 
        Type id_type;
        symbol_table_stack.consult($2.name, id_type);
        if (id_type.base_type != Struct) 
            yyerror("Use new keyword only to instantiate structs");

        Type type(Struct, $2.name);
        std::string var_name = new_var(type, $2.name);
        $$ = new Data(var_name, "", {}, type); 
    }
    | var { 
        $$ = $1;
    }
    | ref_var { 
        $$ = $1;
    }
    | deref_var { 
        $$ = $1;
    }
    | OPEN_PAREN exp CLOSE_PAREN { 
        $$ = new Data(*$2);
    }
    ;

ref_var : KW_REF OPEN_PAREN var CLOSE_PAREN { $$ = new Data(std::string("&")+ $3->var_name, "", {}, Type(Ref, &$3->type)); }

deref_var : KW_DEREF OPEN_PAREN var CLOSE_PAREN { 
              if ($3->type.base_type != Ref) 
                  yyerror("Trying to deref a non ref type");

              $$ = new Data(std::string("*") + $3->var_name, "", {}, *($3->type.referenced_type)); 
          }
          | KW_DEREF OPEN_PAREN deref_var CLOSE_PAREN { 
              if ($3->type.base_type != Ref) 
                  yyerror("Trying to deref a non ref type");

              $$ = new Data(std::string("*") + $3->var_name, "", {}, *($3->type.referenced_type)); 
          }
          ;

var : ID { 
    Type id_type;
    if (!symbol_table_stack.consult($1.name, id_type)) {
        std::string error_message = "var \'";
        error_message += $1.name;
        error_message += "\' not declared";
        yyerror(error_message.c_str());
    }
    
    $$ = new Data($1.name, "", {}, Type(id_type)); 
}
| exp KW_DOT ID {
    std::string struct_name = $1->type.struct_type_name;
    if ($1->type.base_type != Struct) 
        yyerror("Use the dot reference operation only for structs");

    Type struct_type, member_type;
    if (!symbol_table_stack.consult(struct_name, struct_type)) {
        // Should never fall here
        std::string error_message = "struct \'";
        error_message += struct_name;
        error_message += "\' not declared";
        yyerror(error_message.c_str());
    }

    if (!struct_type.symbol_table->consult($3.name, member_type)) {
        std::string error_message = "No member \'";
        error_message += $3.name;
        error_message += "\' in ";
        error_message += struct_name;
        yyerror(error_message.c_str());
    }
    
    $$ = new Data($1->var_name + "." + $3.name, "", {}, Type(member_type)); 
}
;

literal : FLOAT_LITERAL {
    $$ = new Literal(Type(Float), $1.value);
}
| INT_LITERAL {
    $$ = new Literal(Type(Int), $1.value);
}
| STRING_LITERAL {
    $$ = new Literal(Type(String), $1.value);
}
| bool_literal { 
    $$ = new Literal(*$1); 
} 
| KW_NULL {
    $$ = new Literal(Type(Ref, nullptr), "null");
}
;

bool_literal : KW_TRUE {
    $$ = new Literal(Type(Bool), "true");
}
| KW_FALSE {
    $$ = new Literal(Type(Bool), "false");
}
;

assign_stmt : var OP_ASSIGN exp {
                assert_type(&$1->type, &$3->type);
                $$ = new StmtListType();
                conc_list_in_place(*$$, $3->stmt_list);
                $$->push_back($1->var_name + " = " + $3->var_name + ";\n");
            }
            | deref_var OP_ASSIGN exp {
                assert_type(&$1->type, &$3->type);
                $$ = new StmtListType();
                conc_list_in_place(*$$, $3->stmt_list);
                $$->push_back($1->var_name + " = " + $3->var_name + ";\n");
            }
            ;

opt_else_stmt : /* empty */ { 
                  StmtListType stmt_list;
                  std::string label = new_label();
                  stmt_list.push_back(label + ":\n");
                  $$ = new Data("", label, stmt_list, Type(NoType));
              }
              | KW_ELSE opt_stmt_list {
                  StmtListType stmt_list;
                  std::string label = new_label();
                  stmt_list.push_back(label + ":\n");
                  conc_list_in_place(stmt_list, *$2);
                  $$ = new Data("", label, stmt_list, Type(NoType));
              }
              ;

if_stmt : KW_IF exp {assert_condition(&($2->type));} KW_THEN opt_stmt_list opt_else_stmt KW_FI {
            StmtListType stmt_list;
            stmt_list.push_back(std::string("if (!") + $2->var_name + ") goto " + $6->label + ";\n");
            conc_list_in_place(stmt_list, *$5);
            std::string end_if_stmt_label = new_label();
            stmt_list.push_back(std::string("goto ") + end_if_stmt_label + ";\n");
            conc_list_in_place(stmt_list, $6->stmt_list);
            stmt_list.push_back(end_if_stmt_label + ":\n");

            $$ = new StmtListType(stmt_list);
        }
        ;

while_stmt : KW_WHILE exp {assert_condition(&($2->type));} KW_DO opt_stmt_list KW_OD {
               $$ = new StmtListType();
               std::string begin_while = new_label("begin_while");
               $$->push_back(begin_while + ":\n");
               conc_list_in_place(*$$, $2->stmt_list);
               std::string end_while = new_label("end_while");
               $$->push_back("if (!" + $2->var_name + ") goto " + end_while + ";\n");
               conc_list_in_place(*$$, *$5);
               $$->push_back("goto " + begin_while + ";\n");
               $$->push_back(end_while + ":\n");
           }
           ;

return_stmt : KW_RETURN exp {
    StmtListType stmt_list;
    conc_list_in_place(stmt_list, $2->stmt_list);
    stmt_list.push_back("returned_value = " + $2->var_name + ";\n");
    stmt_list.push_back("goto return_label;");
    $$ = new Data("", "", stmt_list, $2->type);
}
;

opt_arguments_list : /* empty */ { $$ = new DataList(); }
                   | argument_list { 
                       $$ = new DataList();
                       *$$ = *$1; 
                   }
                   ;

argument_list : exp { 
                  $$ = new DataList();
                  $$->push_back($1);
              }
              | argument_list KW_COMMA exp {
                  // TODO see error case 1
                  $$ = $1;
                  $$->push_back($3);
              }

call_stmt : ID OPEN_PAREN opt_arguments_list CLOSE_PAREN {
    Type proc_type;
    if (!symbol_table_stack.consult($1.name, proc_type)) {
        std::string error_message = "procedure \'";
        error_message += $1.name;
        error_message += "\' not declared";
        yyerror(error_message.c_str());
    }

    // Check if number of arguments passed match with expected number of arguments
    DataList param_types = *$3;
    DataList expected_param_types = proc_type.param_types;
    if (param_types.size() != expected_param_types.size()) {
        std::string error_message = "Procedure \'";
        error_message += $1.name;
        error_message += "\' expected ";
        error_message += std::to_string(expected_param_types.size());
        error_message += " arguments, but received ";
        error_message += std::to_string(param_types.size());
        yyerror(error_message.c_str());
    }
    
    // Check if arguments types match with expected types and initialize them
    StmtListType stmt_list;
    for (int idx = 0; idx < param_types.size(); ++idx) {
        if (!types_match(param_types[idx]->type, expected_param_types[idx]->type)) {
            std::string error_message = "Argument ";
            error_message += std::to_string(idx);
            error_message += " does not match expected type for procedure \'";
            error_message += $1.name;
            error_message += "\'";
            yyerror(error_message.c_str());
        }

        stmt_list.push_back(expected_param_types[idx]->var_name + " = " + param_types[idx]->var_name + ";\n");
    }
     
    int return_key = new_return_label(stmt_list);
    push_return_key(stmt_list, return_key);
    stmt_list.push_back("return_keys[return_keys_size++] = " + std::to_string(return_key) + ";\n");
    stmt_list.push_back(std::string("goto ") + $1.name + ";\n");
    stmt_list.push_back(std::string("return_label") + std::to_string(return_key) + ":\n");
    $$ = new Data("", "", stmt_list, Type(*(proc_type.return_type)));
}
;

// TODO current_end_do_while_label is a terrible strategy
do_while : KW_DO {do_while_end_stack.push(new_label("end_do_while"));} opt_do_while_stmt_list KW_OD {
             $$ = new StmtListType();
             std::string begin_while = new_label("begin_while");
             $$->push_back(begin_while + ":\n");
             conc_list_in_place(*$$, *$3);
             $$->push_back("goto " + begin_while + ";\n");
             $$->push_back(do_while_end_stack.top() + ":\n");
             do_while_end_stack.pop();
         }
         ;

opt_do_while_stmt_list : /* empty */ {
                           $$ = new StmtListType();
                       }
                       | do_while_stmt_list {
                           $$ = new StmtListType();
                           conc_list_in_place(*$$, *$1);
                       }

do_while_stmt_list : do_while_stmt {
                       $$ = new StmtListType();
                       conc_list_in_place(*$$, *$1);
                   }
                   | do_while_stmt_list KW_SEMICOLUMN do_while_stmt {
                       // TODO see error case 1
                       $$ = $1;
                       conc_list_in_place(*$$, *$3);
                   }

do_while_stmt : if_stmt { 
                  $$ = new StmtListType();
                  conc_list_in_place(*$$, *$1);
              }
              | assign_stmt {
                  $$ = new StmtListType();
                  conc_list_in_place(*$$, *$1);
              }
              | return_stmt {
                  $$ = new StmtListType();
                  conc_list_in_place(*$$, $1->stmt_list);
              }
              | call_stmt {
                  $$ = new StmtListType();
                  conc_list_in_place(*$$, $1->stmt_list);
              }
              | while_stmt { 
                  $$ = new StmtListType();
                  conc_list_in_place(*$$, *$1);
              } 
              | do_while {
                  $$ = new StmtListType();
                  conc_list_in_place(*$$, *$1);
              }
              | KW_EXIT KW_WHEN exp { 
                  assert_condition(&$3->type); 
                  $$ = new StmtListType();
                  conc_list_in_place(*$$, $3->stmt_list);
                  $$->push_back("if (" + $3->var_name + ")" + std::string("goto ") + do_while_end_stack.top() + ";\n");
              }
              ;

type : KW_FLOAT { $$ = new Type(Float); }
     | KW_INT { $$ = new Type(Int); }
     | KW_STRING { $$ = new Type(String); }
     | KW_BOOL { $$ = new Type(Bool); }
     | ID { $$ = new Type(Struct, $1.name); }
     | KW_REF OPEN_PAREN type CLOSE_PAREN { $$ = new Type(Ref, $3); }
     ;

%%
